/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "i2c.h"
#include "rtc.h"
#include "tim.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "delay_us.h"
#include "fnd.h"
#include "lcd.h"
#include "servo.h"
#include "stepper.h"
#include "led.h"
#include "button.h"
#include "buzzer.h"
#include "elevator.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
uint8_t floorPre;				// 현재 층
uint8_t floorState;				// 상황
uint8_t floorPS;				// 층별 상황

// Button 입력 변수
uint8_t floorFlag1;				// 내부 1층
uint8_t floorFlag2;				// 내부 2층
uint8_t floorFlag3;				// 내부 3층
uint8_t doorFlag;				// 내부 열림
uint8_t emgFlag;				// 내부 긴급
uint8_t outFlag1_up;			// 외부 1층 UP
uint8_t outFlag2_up;			// 외부 2층 UP
uint8_t outFlag2_dn;			// 외부 2층 DOWN
uint8_t outFlag3_dn;			// 외부 3층 DOWN

// 긴급 상황 해제시 이전 동작 복귀를 위한 현재 층, 상황 기억 변수
uint8_t emgFloor;
uint8_t emgState;

// Photo Interrupter 입력 변수
uint8_t rxDataF1;				// 1층 도착
uint8_t rxDataF2;				// 2층 도착
uint8_t rxDataF3;				// 3층 도착
uint8_t rxDataD0;				// 문 사이 감지

// Tick 이용 Delay 설정을 위한 변수
uint32_t curTick;				// 현재 Tick 값
uint32_t lastTick;				// 갱신 Tick 값
uint32_t basicTick = 5;			// 단위 Tick 값, 5ms

uint8_t doorIndex;				// 문 열림 Delay 측정 변수
uint8_t doorIndex_s = 100;		// 문 열림 Delay 값 5ms * 100 = 500ms
uint8_t servoIndex;				// Servo 동작 Delay 측정 변수
uint8_t servoIndex_s = 3;		// Servo 동작 Delay 값 5ms * 3 = 15ms
uint8_t ledIndex;				// LED 출력 Delay 측정 변수
uint8_t ledIndex_s = 20;		// LED 출력 Delay 값 5ms * 20 = 100ms
uint8_t emgIndex;				// 비상 Button Debounce 위한 Delay 측정 변수
uint8_t emgIndex_s = 150;		// 비상 Button Debounce 위한 Delay 값 5ms * 150 = 750ms
uint8_t bzIndex;				// Buzzer 소리 변화 Delay 측정 변수
uint8_t bzIndex_s = 30;			// Buzzer 소리 변화 Delay 값 5ms * 30 = 150ms

uint8_t fndState = 1;			// FND Toggle 출력 위한 변수
uint8_t bzState = 0;			// Buzzer 음 변화 위한 변수

RTC_TimeTypeDef sTime;
RTC_DateTypeDef sDate;

uint8_t hour;
uint8_t min;
uint8_t sec;
uint16_t subsec;
char rtcTime[16];
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */
// EXTI 이용한 Button 입력 확인
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
		if (GPIO_Pin == GPIO_PIN_8) {
			floorFlag1 = 1;			// 내부 1층
		}
		else if (GPIO_Pin == GPIO_PIN_6) {
			floorFlag2 = 1;			// 내부 2층
		}
		else if (GPIO_Pin == GPIO_PIN_5) {
			floorFlag3 = 1;			// 내부 3층
		}
		else if (GPIO_Pin == GPIO_PIN_12) {
			doorFlag = 1;			// 내부 열림
		}
		else if (GPIO_Pin == GPIO_PIN_10) {
			outFlag1_up = 1;		// 외부 1층 UP
		}
		else if (GPIO_Pin == GPIO_PIN_11) {
			outFlag2_up = 1;		// 외부 2층 UP
		}
		else if (GPIO_Pin == GPIO_PIN_2) {
			outFlag2_dn = 1;		// 외부 2층 DOWN
		}
		else if (GPIO_Pin == GPIO_PIN_1) {
			outFlag3_dn = 1;		// 외부 3층 DOWN
		}
}
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_TIM3_Init();
  MX_TIM11_Init();
  MX_TIM2_Init();
  MX_RTC_Init();
  /* USER CODE BEGIN 2 */
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);			// TIMER2 CHANNEL1 PWM mode 시작, Servo 작동
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);			// TIMER3 CHANNEL1 PWM mode 시작, Buzzer 작동
  HAL_TIM_Base_Start(&htim11);						// TIMER11 기본 mode 시작
  i2cLCD_Init();									// LCD 초기화
  servoInit();										// Servo 초기화
  ledInit();										// LED 초기화
  floorPre = 0;										// 층 초기화
  floorState = 0;									// 상황 초기화

  // 00:00:00
  sTime.Hours = 0x09;
  sTime.Minutes = 0x40;
  sTime.Seconds = 0x00;
  sTime.TimeFormat = RTC_HOURFORMAT_24;

  // 00-00-00
  sDate.Year = 0x25;
  sDate.Month = 0x06;
  sDate.Date = 0x24;
  sDate.WeekDay = RTC_WEEKDAY_TUESDAY;

  HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD);
  HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  curTick = HAL_GetTick();						// Tick 값을 받아옴

	  // 현재 시간 출력
	  HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BCD);
	  HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BCD);

	  hour = ((sTime.Hours >> 4) * 10) + (sTime.Hours & 0x0f);
	  min = ((sTime.Minutes >> 4) * 10) + (sTime.Minutes & 0x0f);
	  sec = ((sTime.Seconds >> 4) * 10) + (sTime.Seconds & 0x0f);
	  subsec = (999 - ((sTime.SubSeconds * 1000) / (hrtc.Init.SynchPrediv + 1))) / 100;

	  sprintf(rtcTime, "%02d:%02d:%02d.%d", hour, min, sec, subsec);

	  moveCursor(1, 2);
	  lcdString(rtcTime);

	  if (buttonGetPressed(0)) {					// Debounce 적용 위해 일반 Input 적용
		  emgFlag = !emgFlag;						// 비상 Button Toggle 적용
		  if (emgFlag == 0) {
			  bzSound(0, 0);						// 비상 해제시 Buzzer 끔
		  }
	  }

	  // Photo Interrupt 입력 수신
	  rxDataF1 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_11);		// 1층 도착
	  rxDataF2 = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_12);		// 2층 도착
	  rxDataF3 = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2);		// 3층 도착
	  rxDataD0 = HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_2);		// 문 사이 감지

	  // if문과 Flag, rxData 등의 변수를 이용해서 상황을 판단하고, 상황에 따라 동작을 수행하게 합니다.
	  // 전체 상황의 구분은
	  // 1층 5가지 - 문 닫힘, 문 열림중, 문 열림, 문 닫힘중, 상승
	  // 2층 6가지 - 문 닫힘, 문 열림중, 문 열림, 문 닫힘중, 상승, 하강
	  // 3층 5가지 - 문 닫힘, 문 열림중, 문 열림, 문 닫힘중, 하강

	  // 비상 상황
	  if (emgFlag == 1) {							// 내부 비상 눌리면
		  emgFloor = floorPre;						// 이전 층 기억
		  emgState = floorState;					// 이전 상황 기억
		  floorPre = 0;
		  floorState = 0;							// 비상 상황으로
	  }

	  // 초기 시작시 층 찾기 상황
	  else if (floorPre == 0) {						// 초기에 시작시 층을 알 수 없을때
		  if (rxDataF1 == 1) {						// 1층 도착 상태면
			  floorPre = 1;
			  floorState = 0;						// 1층 문 닫힘 상황으로
		  }
		  else if (rxDataF2 == 1) {					// 2층 도착 상태면
			  floorPre = 2;
			  floorState = 0;						// 2층 문 닫힘 상황으로
		  }
		  else if (rxDataF3 == 1) {					// 3층 도착 상태면
			  floorPre = 3;
			  floorState = 0;						// 3층 문 닫힘 상황으로
		  }
		  else {
			  floorState = 7;						// 층을 알 수 없으면 층 찾기 상황으로
		  }
	  }

	  // 1층 발생 가능  상황
	  else if (floorPre == 1) {
		  if (floorState == 0) {					// 1층 문 닫힘 발생 가능 상황
			  // 내부 열림, 외부 1층 UP 눌리면
			  if (doorFlag == 1 || outFlag1_up == 1) {
				  floorState = 1;					// 1층 문 열림중 상황으로
				  doorFlag = 0;						// 내부 열림 해제
				  outFlag1_up = 0;					// 외부 1층 UP 해제
			  }
			  else if (floorFlag1 == 1) {			// 내부 1층 눌리면
				  floorFlag1 = 0;					// 현재 1층이기 때문에 해제
			  }
			  // 내부 2층, 내부 3층, 외부 2층 DOWN, 외부 2층 UP, 외부 3층 DOWN 눌리면
			  else if (floorFlag2 == 1 || floorFlag3 == 1 || outFlag2_dn == 1
					  || outFlag2_up == 1 || outFlag3_dn == 1) {
				  floorState = 6;					// 1층 상승 상황으로
			  }
		  }
		  else if (floorState == 1) {				// 1층 문 열림중 발생 가능 상황
			  if (servoPos == 120) {				// 문이 끝까지 열리면
				  floorState = 2;					// 1층 문 열림 상황으로
			  }
		  }
		  else if (floorState == 2) {				// 1층 문 열림 발생 가능 상황
			  if ((curTick - lastTick) >= basicTick) {
				  doorIndex++;
				  bzIndex++;
				  lastTick = curTick;
			  }
			  if (doorIndex >= doorIndex_s) {		// Tick Delay 시간 만큼 문 열림 유지 후
				  floorState = 3;					// 1층 문 닫힘중 상황으로
				  ledOff(8);						// LED 초기화
				  doorIndex = 0;
			  }
			  if (bzIndex >= bzIndex_s) {			// Buzzer 음 변화
				  bzState++;
				  if (bzState >= 3) {
					  bzState = 0;
				  }
				  bzIndex = 0;
			  }
		  }
		  else if (floorState == 3) {				// 1층 문 닫힘중 발생 가능 상황
			  if (servoPos == 30) {					// 문이 끝까지 닫히면
				  floorState = 0;					// 1층 문 닫힘 상황으로
			  }
			  // 내부 열림, 외부 1층 UP 눌리거나 문 사이 감지되면
			  if (doorFlag == 1 || outFlag1_up == 1 || rxDataD0 == 1) {
				  floorState = 1;					// 1층 문 열림중 상황으로
				  doorFlag = 0;						// 내부 열림 해제
				  outFlag1_up = 0;					// 외부 1층 UP 해제
			  }										// 문 감지 해제 되지 않는한 1층 문 열림중 상황으로
		  }
		  else if (floorState == 6) {				// 1층 상승 발생 가능 상황
			  if (floorFlag1 == 1) {				// 내부 1층 눌리면
				  floorFlag1 = 0;					// 방향이 다르므로 내부 1층 해제
			  }
			  // 내부 2층, 외부 2층 UP 눌렸는데
			  else if (floorFlag2 == 1 || outFlag2_up == 1) {
				  if (rxDataF2 == 1) {				// 2층 도착하면
					  floorPre = 2;
					  floorState = 1;				// 2층 문 열림중 상황으로
					  floorFlag2 = 0;				// 내부 2층 해제
					  outFlag2_up = 0;				// 외부 2층 UP 해제
				  }
			  }
			  // 내부 2층, 외부 2층 UP 모두 안눌렸는데
			  else if (floorFlag2 == 0 && outFlag2_up == 0) {
				  // 내부 3층, 외부 3층 DOWN 눌렸으면
				  if (floorFlag3 == 1 || outFlag3_dn == 1) {
					  if (rxDataF2 == 1) {			// 2층 도착하면
						  floorPre = 2;
						  floorState = 6;			// 2층 상승 상황으로
					  }
				  }
			  }
		  }
	  }

	  // 2층에서 발생할 수 있는 상황
	  else if (floorPre == 2) {
		  if (floorState == 0) {					// 2층 문 닫힘 발생 가능 상황
			  // 내부 열림, 외부 2층 UP, 외부 2층 DOWN 눌리면
			  if (doorFlag == 1 || outFlag2_up == 1 || outFlag2_dn == 1) {
				  floorState = 1;					// 2층 문 열림중 상황으로
				  doorFlag = 0;						// 내부 열림 해제
				  outFlag2_up = 0;					// 외부 2층 UP 해제
				  outFlag2_dn = 0;					// 외부 2층 DOWN 해제
			  }
			  // 내부 1층, 외부 1층 UP 눌리면
			  else if (floorFlag1 == 1 || outFlag1_up == 1) {
				  floorState = 7;					// 2층 하강 상황으로
			  }
			  else if (floorFlag2 == 1) {			// 내부 2층 눌리면
				  floorFlag2 = 0;					// 현재 2층이기 때문에 해제
			  }
			  // 내부 3층, 외부 3층 DOWN 눌리면
			  else if (floorFlag3 == 1 || outFlag3_dn == 1) {
				  floorState = 6;					// 2층 상승 상황으로
			  }
		  }
		  else if (floorState == 1) {				// 2층 문 열림중 발생 가능 상황
			  if (servoPos == 120) {				// 문이 끝까지 열리면
				  floorState = 2;					// 2층 문 열림 상황으로
			  }
		  }
		  else if (floorState == 2) {				// 2층 문 열림 발생 가능 상황
			  if ((curTick - lastTick) >= basicTick) {
				  doorIndex++;
				  bzIndex++;
				  lastTick = curTick;
			  }
			  if (doorIndex >= doorIndex_s) {		// Tick Delay 시간 만큼 문 열림 유지 후
				  floorState = 3;					// 2층 문 닫힘중 상황으로
				  ledOff(8);						// LED 초기화
				  doorIndex = 0;
			  }
			  if (bzIndex >= bzIndex_s) {			// Buzzer 음 변화
				  bzState++;
				  if (bzState >= 3) {
					  bzState = 0;
				  }
				  bzIndex = 0;
			  }
		  }
		  else if (floorState == 3) {				// 2층 문 닫힘중 발생 가능 상황
			  if (servoPos == 30) {					// 문이 끝까지 닫히면
				  floorState = 0;					// 2층 문 닫힘 상황으로
			  }
			  // 내부 열림, 외부 2층 UP, 외부 2층 DOWN 눌리거나 문 사이 감지되면
			  if (doorFlag == 1 || outFlag2_up == 1 || outFlag2_dn == 1 || rxDataD0 == 1) {
				  floorState = 1;					// 2층 문 열림중 상황으로
				  doorFlag = 0;						// 내부 열림 해제
				  outFlag2_up = 0;					// 외부 2층 UP 해제
				  outFlag2_dn = 0;					// 외부 2층 DOWN 해제
			  }										// 문 감지 해제 되지 않는한 2층 문 열림중 상황으로
		  }
		  else if (floorState == 6) {				// 2층 상승 발생 가능 상황
			  // 내부 1층, 내부 2층 눌렸는데
			  if (floorFlag1 == 1 || floorFlag2 == 1) {
				  floorFlag1 = 0;					// 방향이 다르므로 내부 1층 해제
				  floorFlag2 = 0;					// 방향이 다르므로 내부 2층 해제
			  }
			  // 내부 3층, 외부 3층 DOWN 눌렸는데
			  else if (floorFlag3 == 1 || outFlag3_dn == 1) {
				  if (rxDataF3 == 1) {				// 3층 도착하면
					  floorPre = 3;
					  floorState = 1;				// 3층 문 열림중 상황으로
					  floorFlag3 = 0;				// 내부 3층 해제
					  outFlag3_dn = 0;				// 외부 3층 DOWN 해제
				  }
			  }
		  }
		  else if (floorState == 7) {				// 2층 하강 발생 가능 상황
			  // 내부 1층, 외부 1층 UP 눌렸는데
			  if (floorFlag1 == 1 || outFlag1_up == 1) {
				  if (rxDataF1 == 1) {				// 1층 도착하면
					  floorPre = 1;
					  floorState = 1;				// 1층 문 열림중 상황으로
					  floorFlag1 = 0;				// 내부 1층 해제
					  outFlag1_up = 0;				// 외부 1층 UP 해제
				  }
			  }
			  // 내부 2층, 내부 3층 눌렸는데
			  else if (floorFlag2 == 1 || floorFlag3 == 1) {
				  floorFlag2 = 0;					// 방향이 다르므로 내부 2층 해제
				  floorFlag3 = 0;					// 방향이 다르므로 내부 3층 해제
			  }
		  }
	  }

	  // 3층에서 발생할 수 있는 상황
	  else if (floorPre == 3) {
		  if (floorState == 0) {					// 3층 문 닫힘 발생 가능 상황
			  // 내부 열림, 외부 3층 DOWN 눌리면
			  if (doorFlag == 1 || outFlag3_dn == 1) {
				  floorState = 1;					// 3층 문 열림중 상황으로
				  doorFlag = 0;						// 내부 열림 해제
				  outFlag3_dn = 0;					// 외부 3층 DOWN 해제
			  }
			  // 내부 1층, 내부 2층, 외부 1층 UP, 외부 2층 UP, 외부 2층 DOWN 눌리면
			  else if (floorFlag1 == 1 || floorFlag2 == 1 || outFlag1_up == 1
					  || outFlag2_up == 1 || outFlag2_dn == 1) {
				  floorState = 7;					// 3층 하강 상황으로
			  }
			  else if (floorFlag3 == 1) {			// 내부 3층 눌리면
				  floorFlag3 = 0;					// 현재 3층이기 때문에 해제
			  }
		  }
		  else if (floorState == 1) {				// 3층 문 열림중 발생 가능 상황
			  if (servoPos == 120) {				// 문이 끝까지 열리면
				  floorState = 2;					// 3층 문 열림 상황으로
			  }
		  }
		  else if (floorState == 2) {				// 3층 문 열림 발생 가능 상황
			  if ((curTick - lastTick) >= basicTick) {
				  doorIndex++;
				  bzIndex++;
				  lastTick = curTick;
			  }
			  if (doorIndex >= doorIndex_s) {		// Tick Delay 시간 만큼 문 열림 유지 후
				  floorState = 3;					// 3층 문 닫힘중 상황으로
				  ledOff(8);						// LED 초기화
				  doorIndex = 0;
			  }
			  if (bzIndex >= bzIndex_s) {			// Buzzer 음 변화
				  bzState++;
				  if (bzState >= 3) {
					  bzState = 0;
				  }
				  bzIndex = 0;
			  }
		  }
		  else if (floorState == 3) {				// 3층 문 닫힘중 발생 가능 상황
			  if (servoPos == 30) {					// 문이 끝까지 닫히면
				  floorState = 0;					// 3층 문 닫힘 상황으로
			  }
			  // 내부 열림, 외부 3층 DOWN 눌리거나 문 사이 감지되면
			  if (doorFlag == 1 || outFlag3_dn == 1 || rxDataD0 == 1) {
				  floorState = 1;					// 3층 문 열림중 상황으로
				  doorFlag = 0;						// 내부 열림 해제
				  outFlag3_dn = 0;					// 외부 3층 DOWN 해제
			  }										// 문 감지 해제 되지 않는한 문 열림중 상황으로
		  }
		  else if (floorState == 7) {				// 3층 하강 발생 가능 상황
			  // 내부 2층, 외부 2층 DOWN 눌렸는데
			  if (floorFlag2 == 1 || outFlag2_dn == 1) {
				  if (rxDataF2 == 1) {				// 2층 도착하면
					  floorPre = 2;
					  floorState = 1;				// 2층 문 열림중 상황으로
					  floorFlag2 = 0;				// 내부 2층 해제
					  outFlag2_dn = 0;				// 외부 2층 DOWN 해제
				  }
			  }
			  // 내부 2층, 외부 2층 UP 안울렸는데
			  else if (floorFlag2 == 0 && outFlag2_up == 0) {
				  // 내부 1층, 외부 1층 UP 눌렸으면
				  if (floorFlag1 == 1 || outFlag1_up == 1) {
					  if (rxDataF2 == 1) {			// 2층 도착하면
						  floorPre = 2;
						  floorState = 7;			// 2층 하강 상황으로
					  }
				  }
			  }
			  else if (floorFlag3 == 1) {			// 내부 3층 눌리면
				  floorFlag3 = 0;					// 방향이 다르므로 내부 3층 해제
			  }
		  }
	  }

	  // 현재 층(10의 자리)과 상황(1의 자리)으로 상황 변수를 생성
	  floorPS = (floorPre * 10) + floorState;

	  // 상황별 동작 설정
	  switch (floorPS) {
	    case 0:				// 비상 상황
	    	if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
	    		emgIndex++;
				lastTick = curTick;
			}
	    	if (emgIndex >= emgIndex_s) {
	    		if (fndState == 1) {						// 켜짐 상태면
		    		moveCursor(0, 0);
		    		lcdString("EMERGENCY       ");			// 비상 문구 LCD 출력
		    		fndDisplay_CC(0, 0);					// FND 0 출력
		    		ledOn(8);								// LED Bar 전체 ON
		    		bzSound(4, 700);						// Buzzer 솔, 조금 크게
		    		fndState = 0;							// 출력 후 꺼짐 상태로
	    		}
	    		else if (fndState == 0) {					// 꺼짐 상태면
	    			moveCursor(0, 0);
	    			lcdString("Run Away        ");			// 대피 문구 LCD 출력
	    			fndDisplay_CC(2, 0);					// FND 꺼짐, 깜빡임 효과
	    			ledOff(8);								// LED Bar 전체 OFF, 깜빡임 효과
	    			bzSound(0, 300);						// Buzzer 낮은 도, 조금 작게
	    			fndState = 1;							// 출력 후 켜짐 상태로
	    		}
	    		emgIndex = 0;
	    	}
	    	floorPre = emgFloor;							// 이전 층 반환
	    	floorState = emgState;							// 이전 상황 반환
	    	break;

	    case 7:				// 초기 층 찾기 상황
	    	rotateDegrees(10, DIR_CCW);						// Stepper 하강 회전
	    	moveCursor(0, 0);
	    	lcdString("Move to Floor   ");					// 층 찾기 문구 LCD 출력
	    	break;

		case 10:			// 1층 문 닫힘 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("Floor 1 Stop    ");					// 1층 문 닫힘 문구 LCD 출력
			ledOff(8);										// LED Bar 전체 OFF
			break;

		case 11:			// 1층 문 열림중 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("F1 Opening Door ");					// 1층 문 열림중 문구 LCD 출력
			if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
				servoIndex++;
				ledIndex++;
				lastTick = curTick;
			}
			if (ledIndex >= ledIndex_s) {
				ledFlower(8, 0);							// LED Bar 양방향 왕복
				ledIndex = 0;
			}
			if (servoIndex >= servoIndex_s) {
				servoMove(0, 120);							// Servo 끝까지 열림 회전
				servoIndex = 0;
			}
			break;

		case 12:			// 1층 문 열림 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("F1 Open Door    ");					// 1층 문 열림 문구 LCD 출력
			ledOn(8);										// LED Bar 전체 ON
			bzSound((bzState * 2), 500);					// Buzzer 도, 미, 솔 변화
			break;

		case 13:			// 1층 문 닫힘중 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("F1 Closing Door ");					// 1층 문 닫힘중 문구 LCD 출력
			if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
				servoIndex++;
				ledIndex++;
				lastTick = curTick;
			}
			if (ledIndex >= ledIndex_s) {
				ledFlower(8, 0);							// LED Bar 양방향 왕복
				ledIndex = 0;
			}
			if (servoIndex >= servoIndex_s) {
				servoMove(0, 30);							// Servo 끝까지 닫힘 회전
				servoIndex = 0;
			}
			bzSound(0, 0);									// Buzzer 초기화
			break;

		case 16:			// 1층 상승 상황
			if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
				fndState = !fndState;						// 켜짐, 꺼짐 상황 Toggle
				ledOff(8);									// LED Bar 초기화
				ledLeftShift(8, 0);							// LED Bar Shift 상승 표현
				lastTick = curTick;
			}
			if (fndState == 1) {
				fndDisplay_CC(0, floorPre);					// FND 현재층 출력
			}
			else if (fndState == 0) {
				fndDisplay_CC(2, floorPre);					// FND 꺼짐, 깜빡임 효과
			}
			moveCursor(0, 0);
			lcdString("Move to Floor 2 ");					// 2층 이동 문구 LCD 출력
			rotateDegrees(10, DIR_CW);						// Stepper 상승 회전
			break;

		case 20:			// 2층 문 닫힘 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("Floor 2 Stop    ");					// 2층 문 닫힘 문구 LCD 출력
			ledOff(8);										// LED Bar 전체 OFF
			break;

		case 21:			// 2층 문 열림중 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("F2 Opening Door ");					// 2층 문 열림중 문구 LCD 출력
			if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
				servoIndex++;
				ledIndex++;
				lastTick = curTick;
			}
			if (ledIndex >= ledIndex_s) {
				ledFlower(8, 0);							// LED Bar 양방향 왕복
				ledIndex = 0;
			}
			if (servoIndex >= servoIndex_s) {
				servoMove(0, 120);							// Servo 끝까지 열림 회전
				servoIndex = 0;
			}
			break;

		case 22:			// 2층 문 열림 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("F2 Open Door    ");					// 2층 문 열림 문구 LCD 출력
			ledOn(8);										// LED Bar 전체 ON
			bzSound((bzState * 2), 500);					// Buzzer 도, 미, 솔 변화
			break;

		case 23:			// 2층 문 닫힘중 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("F2 Closing Door ");					// 2층 문 닫힘중 문구 LCD 출력
			if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
				servoIndex++;
				ledIndex++;
				lastTick = curTick;
			}
			if (ledIndex >= ledIndex_s) {
				ledFlower(8, 0);							// LED Bar 양방향 왕복
				ledIndex = 0;
			}
			if (servoIndex >= servoIndex_s) {
				servoMove(0, 30);							// Servo 끝까지 닫힘 회전
				servoIndex = 0;
			}
			bzSound(0, 0);									// Buzzer 초기화
			break;

		case 26:			// 2층 상승 상황
			if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
				fndState = !fndState;						// 켜짐, 꺼짐 상황 Toggle
				ledOff(8);									// LED Bar 초기화
				ledLeftShift(8, 0);							// LED Bar Shift 상승 표현
				lastTick = curTick;
			}
			if (fndState == 1) {
				fndDisplay_CC(0, floorPre);					// FND 현재층 출력
			}
			else if (fndState == 0) {
				fndDisplay_CC(2, floorPre);					// FND 꺼짐, 깜빡임 효과
			}
			moveCursor(0, 0);
			lcdString("Move to Floor 3 ");					// 3층 이동 문구 LCD 출력
			rotateDegrees(10, DIR_CW);						// Stepper 상승 회전
			break;

		case 27:			// 2층 하강 상황
			if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
				fndState = !fndState;						// 켜짐, 꺼짐 상황 Toggle
				ledOff(8);									// LED Bar 초기화
				ledRightShift(8, 0);						// LED Bar Shift 하강 표현
				lastTick = curTick;
			}
			if (fndState == 1) {
				fndDisplay_CC(0, floorPre);					// FND 현재층 출력
			}
			else if (fndState == 0) {
				fndDisplay_CC(2, floorPre);					// FND 꺼짐, 깜빡임 효과
			}
			moveCursor(0, 0);
			lcdString("Move to Floor 1 ");					// 1층 이동 문구 LCD 출력
			rotateDegrees(10, DIR_CCW);						// Stepper 하강 회전
			break;

		case 30:			// 3층 문 닫힘 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("Floor 3 Stop    ");					// 3층 문 닫힘 문구 LCD 출력
			ledOff(8);										// LED Bar 전체 OFF
			break;

		case 31:			// 3층 문 열림중 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("F3 Opening Door ");					// 3층 문 열림중 문구 LCD 출력
			if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
				servoIndex++;
				ledIndex++;
				lastTick = curTick;
			}
			if (ledIndex >= ledIndex_s) {
				ledFlower(8, 0);							// LED Bar 양방향 왕복
				ledIndex = 0;
			}
			if (servoIndex >= servoIndex_s) {
				servoMove(0, 120);							// Servo 끝까지 열림 회전
				servoIndex = 0;
			}
			break;

		case 32:			// 3층 문 열림 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("F3 Open Door    ");					// 3층 문 열림 문구 LCD 출력
			ledOn(8);										// LED 전체 ON
			bzSound((bzState * 2), 500);					// Buzzer 도, 미, 솔 변화
			break;

		case 33:			// 3층 문 닫힘중 상황
			fndDisplay_CC(0, floorPre);						// FND 현재층 출력
			moveCursor(0, 0);
			lcdString("F3 Closing Door ");					// 3층 문 닫힘중 문구 LCD 출력
			if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
				servoIndex++;
				ledIndex++;
				lastTick = curTick;
			}
			if (ledIndex >= ledIndex_s) {
				ledFlower(8, 0);							// LED Bar 양방향 왕복
				ledIndex = 0;
			}
			if (servoIndex >= servoIndex_s) {
				servoMove(0, 30);							// Servo 끝까지 닫힘 회전
				servoIndex = 0;
			}
			bzSound(0, 0);									// Buzzer 초기화
			break;

		case 37:			// 3층 하강 상황
			if ((curTick - lastTick) >= basicTick) {		// Tick Delay 적용
				fndState = !fndState;						// 켜짐, 꺼짐 상황 Toggle
				ledOff(8);									// LED Bar 초기화
				ledRightShift(8, 0);						// LED Bar Shift 하강 표현
				lastTick = curTick;
			}
			if (fndState == 1) {
				fndDisplay_CC(0, floorPre);					// FND 현재층 출력
			}
			else if (fndState == 0) {
				fndDisplay_CC(2, floorPre);					// FND 꺼짐, 깜빡임 효과
			}
			moveCursor(0, 0);
			lcdString("Move to Floor 2 ");					// 2층 이동 문구 LCD 출력
			rotateDegrees(10, DIR_CCW);						// Stepper 하강 회전
			break;
	}
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 100;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
